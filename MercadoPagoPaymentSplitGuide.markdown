# Configurando a Divisão de Pagamentos com o SDK PHP do Mercado Pago e os Blocos de Checkout no Laravel 12

Este guia fornece uma abordagem passo a passo para implementar a divisão de pagamentos em um marketplace Laravel 12 usando o SDK PHP e os Blocos de Checkout do Mercado Pago. Ele pressupõe que a autenticação de vendedores baseada em OAuth já esteja implementada e se concentra em práticas prontas para produção em 2025.

## Pré-requisitos
- **Laravel 12** com Laravel Breeze para autenticação.
- **SDK PHP do Mercado Pago**: Instale via `composer require "mercadopago/dx-php:2.6.2"` (compatível com PHP 7.1+).[](https://github.com/mercadopago/sdk-php)

- **Credenciais do Mercado Pago**: Chave pública, token de acesso e ID/segredo do cliente OAuth do Painel de Desenvolvedor do Mercado Pago.

- **Integração OAuth do Vendedor**: Os vendedores vincularam suas contas do Mercado Pago, fornecendo `access_token` e `refresh_token`.
- **Ambiente**: Configuração `.env` pronta para produção para credenciais.

## Configuração Passo a Passo

### 1. Install and Configure Mercado Pago SDK
- Run `composer require "mercadopago/dx-php:2.6.2"` to install the SDK.

- Add credentials to `.env`:
  ```
  MERCADO_PAGO_PUBLIC_KEY=your_public_key
  MERCADO_PAGO_ACCESS_TOKEN=your_platform_access_token
  MERCADO_PAGO_CLIENT_ID=your_client_id
  MERCADO_PAGO_CLIENT_SECRET=your_client_secret


  ```
- Crie um arquivo de configuração (`config/mercadopago.php`):
  ```php
  <?php
  return [
      'public_key' => env('MERCADO_PAGO_PUBLIC_KEY'),
      'access_token' => env('MERCADO_PAGO_ACCESS_TOKEN'),
      'client_id' => env('MERCADO_PAGO_CLIENT_ID'),
      'client_secret' => env('MERCADO_PAGO_CLIENT_SECRET'),
  ];
  ```

### 2. Set Up Checkout Bricks Frontend
- Include Mercado Pago's JavaScript library in your Blade template (`resources/views/checkout.blade.php`):
  ```html
  <script src="https://sdk.mercadopago.com/js/v2"></script>
  <div id="paymentBrick_container"></div>
  <script>
      const mp = new MercadoPago('{{ config('mercadopago.public_key') }}', { locale: 'pt-BR' });
      const bricksBuilder = mp.bricks();

      async function renderPaymentBrick() {
          const settings = {
              initialization: {
                  amount: 100.00, // Dynamic amount from backend
                  payer: { email: "{{ auth()->user()->email }}" },
                  preferenceId: "{{ $preferenceId }}", // Generated in backend
              },
              customization: {
                  paymentMethods: {
                      creditCard: 'all',
                      debitCard: 'all',
                      ticket: 'all',
                      bankTransfer: 'all',
                      mercadoPago: 'all',
                  },
              },
              callbacks: {
                  onSubmit: ({ selectedPaymentMethod, formData }) => {
                      return new Promise((resolve, reject) => {
                          fetch('/process-payment', {
                              method: 'POST',
                              headers: {
                                  'Content-Type': 'application/json',
                                  'X-CSRF-TOKEN': '{{ csrf_token() }}',
                              },
                              body: JSON.stringify(formData),
                          })
                          .then(response => response.json())
                          .then(data => {
                              console.log('Payment processed:', data);
                              resolve();
                          })
                          .catch(error => {
                              console.error('Payment error:', error);
                              reject(error);
                          });
                      });
                  },
                  onError: (error) => console.error('Brick error:', error),
              },
          };
          window.paymentBrickController = await bricksBuilder.create('payment', 'paymentBrick_container', settings);
      }
      renderPaymentBrick();
  </script>
  ```
- Ensure `preferenceId` is dynamically generated by the backend (see next step).

### 3. Create Payment Preference with Split Configuration
- Create a controller (`app/Http/Controllers/PaymentController.php`) to handle preference creation:
  ```php
  <?php
  namespace App\Http\Controllers;

  use MercadoPago\SDK;
  use MercadoPago\Preference;
  use MercadoPago\Item;
  use MercadoPago\Payer;
  use Illuminate\Http\Request;

  class PaymentController extends Controller
  {
      public function createPreference(Request $request)
      {
          // Initialize SDK with platform access token
          SDK::setAccessToken(config('mercadopago.access_token'));

          // Fetch seller's access token from database (assumes OAuth flow completed)
          $seller = auth()->user()->seller; // Example: Seller model with access_token
          $sellerAccessToken = $seller->mercadopago_access_token;

          // Create preference
          $preference = new Preference();
          $preference->processing_modes = ['aggregator']; // Marketplace mode
          $preference->marketplace_fee = 10.00; // Platform fee (e.g., 10% or fixed amount)
          $preference->external_reference = 'order_' . uniqid(); // Unique order ID

          // Add items
          $item = new Item();
          $item->id = 'product_123';
          $item->title = 'Product Name';
          $item->quantity = 1;
          $item->unit_price = 100.00;
          $item->currency_id = 'BRL';
          $preference->items = [$item];

          // Set payer
          $payer = new Payer();
          $payer->email = auth()->user()->email;
          $preference->payer = $payer;

          // Split configuration
          $preference->marketplace = [
              'collector_id' => $seller->mercadopago_user_id, // Seller's Mercado Pago user ID
              'application_fee' => 10.00, // Same as marketplace_fee
          ];

          // Save preference using seller's access token
          SDK::setAccessToken($sellerAccessToken);
          $preference->save();

          return response()->json(['preferenceId' => $preference->id]);
      }
  }
  ```
- Register the route in `routes/web.php`:
  ```php
  Route::post('/create-preference', [PaymentController::class, 'createPreference'])->middleware('auth');
  ```

### 4. Process Payment with Checkout Bricks
- Add a payment processing endpoint in `PaymentController.php`:
  ```php
  public function processPayment(Request $request)
  {
      SDK::setAccessToken(config('mercadopago.access_token'));

      $formData = $request->all();
      $payment = new \MercadoPago\Payment();
      $payment->transaction_amount = $formData['transaction_amount'];
      $payment->token = $formData['token']; // Card token from Bricks
      $payment->description = 'Product Purchase';
      $payment->installments = $formData['installments'];
      $payment->payment_method_id = $formData['payment_method_id'];
      $payment->issuer_id = $formData['issuer_id'];
      $payment->payer = [
          'email' => $formData['payer']['email'],
          'identification' => $formData['payer']['identification'],
      ];
      $payment->processing_mode = 'aggregator';
      $payment->application_fee = 10.00; // Platform fee
      $payment->capture = true; // Immediate capture

      // Use seller's access token for payment
      $seller = auth()->user()->seller;
      SDK::setAccessToken($seller->mercadopago_access_token);
      $payment->save();

      return response()->json([
          'status' => $payment->status,
          'payment_id' => $payment->id,
          'error' => $payment->error ?? null,
      ]);
  }
  ```
- Add the route:
  ```php
  Route::post('/process-payment', [PaymentController::class, 'processPayment'])->middleware('auth');
  ```

### 5. Handle Webhooks for Payment Status
- Create a webhook endpoint to receive payment updates:
  ```php
  public function handleWebhook(Request $request)
  {
      SDK::setAccessToken(config('mercadopago.access_token'));

      $event = $request->all();
      if ($event['type'] === 'payment') {
          $payment = \MercadoPago\Payment::find_by_id($event['data']['id']);
          // Update order status in database
          \App\Models\Order::where('mercadopago_payment_id', $payment->id)
              ->update(['status' => $payment->status]);
      }

      return response()->json(['status' => 'received'], 200);
  }
  ```
- Add the route (CSRF-exempt for webhooks):
  ```php
  Route::post('/webhook', [PaymentController::class, 'handleWebhook'])->name('webhook');
  ```
- Configure the webhook URL in the Mercado Pago Developer Panel (e.g., `https://yourdomain.com/webhook`).

## Do’s and Don’ts

### Do
- **Use Seller-Specific Access Tokens**: Always switch to the seller’s OAuth `access_token` when creating preferences or processing payments to ensure funds are split correctly.
- **Validate Webhook Events**: Verify webhook signatures using Mercado Pago’s `X-Signature` header to prevent unauthorized requests.
- **Store Credentials Securely**: Use Laravel’s `.env` and `config` system to manage sensitive data.
- **Test in Sandbox First**: Use test credentials and cards provided in the Mercado Pago Developer Panel before going live.[](https://github.com/mercadopago/card-payment-bricks-sample-php)
- **Handle Token Expiry**: Use `refresh_token` to renew seller access tokens (valid for 180 days) via the `/oauth/token` endpoint.[](https://omega.mercadopago.com.br/developers/en/docs/checkout-bricks/additional-content/security/oauth/creation)

### Don’t
- **Don’t Use Platform Access Token for Seller Actions**: This causes `invalid_caller_id` errors when processing payments.[](https://stackoverflow.com/questions/tagged/mercadopago?tab=Active)
- **Don’t Hardcode Credentials**: Avoid storing `client_id`, `client_secret`, or tokens in code.
- **Don’t Ignore PKCE for OAuth**: Enable PKCE in the Mercado Pago Developer Panel to secure authorization code flows.[](https://omega.mercadopago.com.br/developers/en/docs/checkout-bricks/additional-content/security/oauth/creation)
- **Don’t Skip Webhook Validation**: Failing to validate webhooks can lead to processing fake payment events.
- **Don’t Use Outdated Parameters**: Avoid deprecated fields like `wallet_purchase` in Bricks; use `mercadoPago: 'all'` instead.[](https://stackoverflow.com/questions/78834574/enable-payment-with-mercado-pago-wallet-in-checkout-bricks)

## Best Practices
- **Security**:
  - Enable PKCE for OAuth to prevent authorization code interception.[](https://omega.mercadopago.com.br/developers/en/docs/checkout-bricks/additional-content/security/oauth/creation)
  - Use HTTPS for all API calls and webhook endpoints.
  - Store seller `access_token` and `refresh_token` encrypted in the database (e.g., using Laravel’s encryption).
- **Code Organization**:
  - Create a `MercadoPagoService` class to encapsulate SDK logic:
    ```php
    namespace App\Services;

    use MercadoPago\SDK;
    use MercadoPago\Preference;

    class MercadoPagoService
    {
        public function __construct()
        {
            SDK::setAccessToken(config('mercadopago.access_token'));
        }

        public function createPreference($items, $payer, $seller)
        {
            SDK::setAccessToken($seller->mercadopago_access_token);
            $preference = new Preference();
            $preference->items = $items;
            $preference->payer = $payer;
            $preference->processing_modes = ['aggregator'];
            $preference->marketplace_fee = 10.00;
            $preference->marketplace = [
                'collector_id' => $seller->mercadopago_user_id,
                'application_fee' => 10.00,
            ];
            $preference->save();
            return $preference;
        }
    }
    ```
  - Inject the service into controllers for reusability.
- **Credential Management**:
  - Store seller OAuth tokens in a `sellers` table with columns: `mercadopago_user_id`, `access_token`, `refresh_token`, `token_expires_at`.
  - Schedule a Laravel job to refresh tokens before expiry:
    ```php
    namespace App\Jobs;

    use Illuminate\Bus\Queueable;
    use Illuminate\Contracts\Queue\ShouldQueue;
    use MercadoPago\SDK;

    class RefreshMercadoPagoToken implements ShouldQueue
    {
        use Queueable;

        protected $seller;

        public function __construct($seller)
        {
            $this->seller = $seller;
        }

        public function handle()
        {
            SDK::setAccessToken(config('mercadopago.access_token'));
            $client = new \MercadoPago\OauthClient();
            $request = new \MercadoPago\OAuthCreateRequest();
            $request->client_secret = config('mercadopago.client_secret');
            $request->client_id = config('mercadopago.client_id');
            $request->grant_type = 'refresh_token';
            $request->refresh_token = $this->seller->refresh_token;

            $response = $client->create($request);
            $this->seller->update([
                'access_token' => $response->access_token,
                'refresh_token' => $response->refresh_token,
                'token_expires_at' => now()->addSeconds($response->expires_in),
            ]);
        }
    }
    ```
- **Processing Mode and Fees**:
  - Set `processing_mode` to `aggregator` for marketplace payments.
  - Use `marketplace_fee` and `application_fee` consistently to define the platform’s commission.
  - Ensure `collector_id` matches the seller’s Mercado Pago user ID from their OAuth profile.

## Notes for Production
- **Testing**: Use Mercado Pago’s test cards and sandbox environment to simulate payments.[](https://github.com/mercadopago/card-payment-bricks-sample-php)
- **Error Handling**: Log API errors (e.g., `MPApiException`) and notify admins for critical failures.
- **Monitoring**: Set up Laravel Telescope or similar to monitor webhook performance and payment statuses.
- **Scalability**: Use Laravel’s queue system for webhook processing and token refreshing to handle high transaction volumes.